/**
 * ãƒ­ãƒ¼ã‚«ãƒ«ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹
 * LocalStorageãƒ™ãƒ¼ã‚¹ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ç‰ˆï¼‰
 * å¾Œã§ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«ç§»è¡Œäºˆå®š
 */

import { UserIdentificationService } from './userIdentificationService';

export interface GameScore {
  userId: string;
  gameType: string;
  score: number;
  timestamp: string;
  sessionId: string;
  metadata?: any;
}

export interface RankingEntry {
  rank: number;
  userId: string;
  username?: string;
  displayName: string;
  score: number;
  timestamp: string;
  isCurrentUser: boolean;
}

export interface RankingData {
  rankings: RankingEntry[];
  userRank: RankingEntry | null;
  totalPlayers: number;
  lastUpdated: string;
}

export class LocalRankingService {
  private static instance: LocalRankingService;
  private userService: UserIdentificationService;
  
  private readonly STORAGE_KEYS = {
    GLOBAL_SCORES: 'hunterhub_global_scores',
    RANKING_CACHE: 'hunterhub_ranking_cache',
    LAST_SYNC: 'hunterhub_last_ranking_sync'
  };

  private constructor() {
    this.userService = UserIdentificationService.getInstance();
  }

  public static getInstance(): LocalRankingService {
    if (!LocalRankingService.instance) {
      LocalRankingService.instance = new LocalRankingService();
    }
    return LocalRankingService.instance;
  }

  /**
   * ã‚¹ã‚³ã‚¢ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«é€ä¿¡
   */
  public async submitScore(gameType: string, score: number, metadata?: any): Promise<void> {
    const userId = await this.userService.getCurrentUserId();
    
    const gameScore: GameScore = {
      userId,
      gameType,
      score,
      timestamp: new Date().toISOString(),
      sessionId: `${userId.substring(0, 8)}_${Date.now()}`,
      metadata
    };

    // æ—¢å­˜ã‚¹ã‚³ã‚¢ã‚’å–å¾—
    const allScores = this.getAllScores();
    
    // æ–°ã—ã„ã‚¹ã‚³ã‚¢ã‚’è¿½åŠ 
    allScores.push(gameScore);
    
    // æœ€æ–°1000ä»¶ã®ã¿ä¿æŒï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å¯¾ç­–ï¼‰
    const recentScores = allScores
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 1000);
    
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
    localStorage.setItem(this.STORAGE_KEYS.GLOBAL_SCORES, JSON.stringify(recentScores));
    
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
    this.updateRankingCache(gameType);
    
    console.log(`ğŸ“Š Score submitted: ${gameType} - ${score} (User: ${userId.substring(0, 8)}...)`);
  }

  /**
   * ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  public async getRankings(gameType: string, limit: number = 50): Promise<RankingData> {
    const userId = await this.userService.getCurrentUserId();
    const allScores = this.getAllScores();
    
    // æŒ‡å®šã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒ—ã®ã‚¹ã‚³ã‚¢ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const gameScores = allScores.filter(score => score.gameType === gameType);
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã®æœ€é«˜ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
    const userBestScores = this.calculateUserBestScores(gameScores);
    
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°é †ã«ã‚½ãƒ¼ãƒˆï¼ˆã‚¹ã‚³ã‚¢ãŒé«˜ã„é †ã€åŒã˜å ´åˆã¯æ—¥æ™‚ãŒæ–°ã—ã„é †ï¼‰
    const sortedRankings = userBestScores
      .sort((a, b) => {
        if (b.score !== a.score) return b.score - a.score;
        return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
      })
      .slice(0, limit);
    
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°æƒ…å ±ã‚’ç”Ÿæˆï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼åä»˜ãï¼‰
    const rankings: RankingEntry[] = await Promise.all(
      sortedRankings.map(async (entry, index) => {
        const username = await this.getUsernameByUserId(entry.userId);
        const displayName = username || `ãƒ¦ãƒ¼ã‚¶ãƒ¼${entry.userId.substring(0, 6)}`;
        
        return {
          rank: index + 1,
          userId: entry.userId,
          username,
          displayName,
          score: entry.score,
          timestamp: entry.timestamp,
          isCurrentUser: entry.userId === userId
        };
      })
    );    
    // ç¾åœ¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ©ãƒ³ã‚¯æƒ…å ±ã‚’å–å¾—
    const userRank = rankings.find(entry => entry.isCurrentUser) || null;
    
    return {
      rankings,
      userRank,
      totalPlayers: userBestScores.length,
      lastUpdated: new Date().toISOString()
    };
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
   */
  public async getUserStats(gameType?: string): Promise<{
    totalGames: number;
    bestScore: number | null;
    averageScore: number | null;
    recentGames: GameScore[];
    rank: number | null;
  }> {
    const userId = await this.userService.getCurrentUserId();
    const allScores = this.getAllScores();
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¹ã‚³ã‚¢ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    let userScores = allScores.filter(score => score.userId === userId);
    
    if (gameType) {
      userScores = userScores.filter(score => score.gameType === gameType);
    }
    
    // çµ±è¨ˆè¨ˆç®—
    const totalGames = userScores.length;
    const bestScore = totalGames > 0 ? Math.max(...userScores.map(s => s.score)) : null;
    const averageScore = totalGames > 0 ? userScores.reduce((sum, s) => sum + s.score, 0) / totalGames : null;
    const recentGames = userScores
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 10);
    
    // ãƒ©ãƒ³ã‚¯ã‚’å–å¾—
    let rank: number | null = null;
    if (gameType && bestScore !== null) {
      const rankingData = await this.getRankings(gameType);
      rank = rankingData.userRank?.rank || null;
    }
    
    return {
      totalGames,
      bestScore,
      averageScore: averageScore ? Math.round(averageScore * 100) / 100 : null,
      recentGames,
      rank
    };
  }

  /**
   * å…¨ã‚¹ã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  private getAllScores(): GameScore[] {
    try {
      const scoresData = localStorage.getItem(this.STORAGE_KEYS.GLOBAL_SCORES);
      return scoresData ? JSON.parse(scoresData) : [];
    } catch (error) {
      console.error('Failed to load global scores:', error);
      return [];
    }
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã®æœ€é«˜ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
   */
  private calculateUserBestScores(scores: GameScore[]): GameScore[] {
    const userScoreMap = new Map<string, GameScore>();
    
    scores.forEach(score => {
      const existingScore = userScoreMap.get(score.userId);
      if (!existingScore || score.score > existingScore.score) {
        userScoreMap.set(score.userId, score);
      }
    });
    
    return Array.from(userScoreMap.values());
  }

  /**
   * ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
   */
  private updateRankingCache(gameType: string): void {
    try {
      const cache = this.getRankingCache();
      cache[gameType] = {
        lastUpdated: new Date().toISOString(),
        needsRefresh: true
      };
      localStorage.setItem(this.STORAGE_KEYS.RANKING_CACHE, JSON.stringify(cache));
    } catch (error) {
      console.error('Failed to update ranking cache:', error);
    }
  }

  /**
   * ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å–å¾—
   */
  private getRankingCache(): any {
    try {
      const cacheData = localStorage.getItem(this.STORAGE_KEYS.RANKING_CACHE);
      return cacheData ? JSON.parse(cacheData) : {};
    } catch (error) {
      console.error('Failed to load ranking cache:', error);
      return {};
    }
  }

  /**
   * ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šå…¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  public getDebugInfo(): any {
    const allScores = this.getAllScores();
    const cache = this.getRankingCache();
    
    return {
      totalScores: allScores.length,
      scoresByGame: this.getScoresByGameType(allScores),
      uniqueUsers: new Set(allScores.map(s => s.userId)).size,
      cache,
      storageKeys: this.STORAGE_KEYS,
      storageUsage: this.calculateStorageUsage()
    };
  }

  /**
   * ã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒ—åˆ¥ã‚¹ã‚³ã‚¢çµ±è¨ˆ
   */
  private getScoresByGameType(scores: GameScore[]): Record<string, number> {
    const gameTypeCount: Record<string, number> = {};
    scores.forEach(score => {
      gameTypeCount[score.gameType] = (gameTypeCount[score.gameType] || 0) + 1;
    });
    return gameTypeCount;
  }

  /**
   * ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡è¨ˆç®—
   */
  private calculateStorageUsage(): { totalKB: number; scoreDataKB: number } {
    const scoreData = localStorage.getItem(this.STORAGE_KEYS.GLOBAL_SCORES) || '';
    const totalData = JSON.stringify(localStorage);
    
    return {
      totalKB: Math.round((totalData.length * 2) / 1024), // UTF-16ãªã®ã§2ãƒã‚¤ãƒˆ
      scoreDataKB: Math.round((scoreData.length * 2) / 1024)
    };
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
   */
  public clearAllRankingData(): void {
    Object.values(this.STORAGE_KEYS).forEach(key => {
      localStorage.removeItem(key);
    });
    console.log('ğŸ—‘ï¸ All ranking data cleared');
  }
  /**
   * æŒ‡å®šã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒ—ã®1ä½ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—
   */
  public async getTopPlayer(gameType: string): Promise<RankingEntry | null> {
    try {
      const rankingData = await this.getRankings(gameType, 1);
      return rankingData.rankings.length > 0 ? rankingData.rankings[0] : null;
    } catch (error) {
      console.error('Failed to get top player:', error);
      return null;
    }
  }

  /**
   * å…¨ã‚²ãƒ¼ãƒ ã®1ä½ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¸€æ‹¬å–å¾—
   */
  public async getAllTopPlayers(): Promise<{
    reflex: RankingEntry | null;
    target: RankingEntry | null;
    sequence: RankingEntry | null;
  }> {
    try {
      const [reflexTop, targetTop, sequenceTop] = await Promise.all([
        this.getTopPlayer('reflex'),
        this.getTopPlayer('target'),
        this.getTopPlayer('sequence')
      ]);

      return {
        reflex: reflexTop,
        target: targetTop,
        sequence: sequenceTop
      };
    } catch (error) {

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å–å¾—
   */
  private async getUsernameByUserId(userId: string): Promise<string | null> {
    try {
      return await this.userService.getUsername();
    } catch (error) {
      console.error("Failed to get username:", error);
      return null;
    }
  }      console.error('Failed to get all top players:', error);
      return {
        reflex: null,
        target: null,
        sequence: null
      };
    }
  }
  }
